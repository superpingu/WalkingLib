// Generated by CoffeeScript 1.10.0
(function() {
  var ARGUMENT_NAMES, STRIP_COMMENTS, getParamNames,
    slice = [].slice;

  STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

  ARGUMENT_NAMES = /([^\s,]+)/g;

  getParamNames = function(func) {
    var fnStr, result;
    fnStr = func.toString().replace(STRIP_COMMENTS, '');
    result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
    if (result === null) {
      return [];
    } else {
      return result;
    }
  };

  module.exports = function(robot) {
    var endCallback, nextStage, pushStep, result, sequence, sequencify, stage, stageExec;
    sequence = [[]];
    stage = 0;
    result = {};
    endCallback = null;
    stageExec = 0;
    pushStep = function(func, args) {
      return sequence[stage].push({
        func: func,
        args: args,
        wait: getParamNames(func).pop() === 'callback',
        cbProvided: getParamNames(func).length === args.length
      });
    };
    sequencify = function(obj, key) {
      var k, res;
      if (typeof obj[key] === 'function') {
        res = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          pushStep(obj[key], args);
          return result;
        };
      } else if (typeof obj[key] === 'object') {
        res = {};
        for (k in obj[key]) {
          res[k] = sequencify(obj[key], k);
        }
      }
      return res;
    };
    result = sequencify({
      root: robot
    }, 'root');
    if (result.sequence != null) {
      delete result.sequence;
    }
    nextStage = function() {
      var i, len, ref, task, willCallBack;
      if (stageExec > stage) {
        return typeof endCallback === "function" ? endCallback() : void 0;
      } else {
        willCallBack = false;
        ref = sequence[stageExec];
        for (i = 0, len = ref.length; i < len; i++) {
          task = ref[i];
          task.func.apply(task, task.args);
          if (task.wait) {
            willCallBack = true;
          }
        }
        stageExec++;
        if (sequence[stageExec - 1].length === 0 || !willCallBack) {
          return nextStage();
        }
      }
    };
    result.then = function() {
      var called, cb, i, len, ref, step, waitingSteps;
      waitingSteps = 0;
      called = 0;
      ref = sequence[stage];
      for (i = 0, len = ref.length; i < len; i++) {
        step = ref[i];
        if (!step.wait) {
          continue;
        }
        waitingSteps++;
        if (step.cbProvided) {
          cb = step.args.pop();
        }
        step.args.push(function() {
          if (typeof cb === "function") {
            cb();
          }
          if (++called === waitingSteps) {
            return nextStage();
          }
        });
      }
      stage++;
      sequence[stage] = [];
      return result;
    };
    result.done = function(callback) {
      endCallback = callback;
      return result;
    };
    result.stop = function() {
      stageExec = stage + 1;
      return endCallback = null;
    };
    result.start = function(callback) {
      if (callback != null) {
        result.done(callback);
      }
      stageExec = 0;
      if (sequence[stage].length > 0) {
        result.then();
      }
      nextStage();
      return result;
    };
    result.run = function(func) {
      pushStep(func, []);
      return result;
    };
    result.setSeq = function(seq) {
      sequence = seq.slice();
      return stage = seq.length - 1;
    };
    result.create = function() {
      var seq;
      seq = robot.sequence();
      seq.setSeq(sequence);
      return seq;
    };
    return result;
  };

}).call(this);
